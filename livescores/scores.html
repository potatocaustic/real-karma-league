<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RKL Live Scores</title>
  <style>
    :root {
      --bg-color: #121212;
      --card-color: #1e1e1e;
      --accent-color: #00ff88;
      --text-color: #ffffff;
      --text-muted: #aaa;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Roboto, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      min-height: 100vh;
      padding: 24px;
      max-width: 760px;
      margin: auto;
    }

    h1 {
      text-align: center;
      font-size: 32px;
      margin-bottom: 16px;
    }

    .loading {
      text-align: center;
      font-size: 14px;
      color: var(--accent-color);
      margin-bottom: 16px;
    }

    .home-link {
      display: block;
      text-align: center;
      margin-top: 30px;
      font-size: 14px;
      color: var(--accent-color);
      text-decoration: none;
      transition: opacity 0.2s;
    }

    .home-link:hover {
      opacity: 0.7;
    }

    .game-container {
      background-color: var(--card-color);
      border-radius: 16px;
      margin-bottom: 24px;
      box-shadow: 0 0 12px rgba(0, 255, 136, 0.15);
      overflow: hidden;
    }

    .game-header {
      padding: 16px 20px;
      background-color: #2a2a2a;
      cursor: pointer;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      font-size: 17px;
      transition: background 0.2s ease;
    }

    .game-header:hover {
      background-color: #353535;
    }

    .game-body {
      display: none;
      padding: 20px;
    }

    .team-roster {
      margin-bottom: 24px;
    }

    .roster-title {
      font-weight: bold;
      margin-bottom: 8px;
      color: var(--text-muted);
    }

    .player-row {
      padding: 6px 12px;
      background-color: #333;
      border-radius: 6px;
      margin-bottom: 6px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h1>RKL Live Scores</h1>
  <div class="loading" id="loading-indicator">Loading...</div>
  <div id="games-container"></div>
  <a href="index.html" class="home-link">← Home</a>

  <script type="module">
    import { db, collection, query, where, getDocs, doc, getDoc } from '/js/firebase-init.js';
    import '/js/firebase-public-auth.js';

    // --- DEV ENVIRONMENT CONFIG ---
    const USE_DEV_COLLECTIONS = true;
    const getCollectionName = (baseName) => USE_DEV_COLLECTIONS ? `${baseName}_dev` : baseName;
    
    // --- SCRIPT CONSTANTS ---
    const WORKER_URL = 'https://rkl-karma-proxy.caustic.workers.dev/';
    const karmaCache = new Map();
    const teamNameCache = new Map();

    // --- HELPER FUNCTIONS ---

    function getTodayString() {
        const now = new Date();
        // Use New York time zone to determine the "RKL day"
        const est = new Date(now.toLocaleString("en-US", { timeZone: "America/New_York" }));
        // If it's before 7 AM ET, the "day" is still the previous day
        if (est.getHours() < 7) {
            est.setDate(est.getDate() - 1);
        }
        // Format to M/D/YYYY for matching Firestore 'date' field
        return `${est.getMonth() + 1}/${est.getDate()}/${est.getFullYear()}`;
    }

    async function fetchKarma(userId) {
        if (karmaCache.has(userId)) return karmaCache.get(userId);
        try {
            const res = await fetch(`${WORKER_URL}?userId=${encodeURIComponent(userId)}`);
            const data = await res.json();
            const val = parseFloat(data?.stats?.karmaDelta || 0);
            karmaCache.set(userId, val);
            return val;
        } catch (error) {
            console.error(`Failed to fetch karma for ${userId}:`, error);
            return 0; // Return 0 on failure
        }
    }

    async function limitedMap(array, limit, asyncFn, onProgress) {
        const results = [];
        let index = 0;
        const executing = new Set();
        for (const item of array) {
            const p = asyncFn(item).then(res => {
                results.push(res);
                if (onProgress) onProgress(++index, array.length);
            });
            executing.add(p);
            p.finally(() => executing.delete(p));
            if (executing.size >= limit) await Promise.race(executing);
        }
        await Promise.all(executing);
        return results;
    }

    async function processTeam(players, updateProgress) {
        let teamTotal = 0;
        const rows = await limitedMap(players, 10, async p => {
            const userId = p.player_id?.trim();
            const userHandle = p.player_handle?.trim() || 'Unknown';
            const isCaptain = p.is_captain === true || p.is_captain === 'TRUE';
            const deduction = parseFloat(p.deductions || 0);

            if (!userId) return `<div class="player-row">${userHandle}: Missing ID</div>`;
            
            const base = await fetchKarma(userId);
            const adjusted = base - deduction;
            const boosted = isCaptain ? adjusted * 1.5 : adjusted;
            
            teamTotal += boosted;
            
            const rounded = Math.round(adjusted);
            const label = isCaptain
                ? `${userHandle} (C): ${rounded} → ${Math.round(boosted)}`
                : `${userHandle}: ${rounded}`;
            
            return `<div class="player-row">${label}</div>`;
        }, updateProgress);
        return { rows, total: Math.round(teamTotal) };
    }

    function createGameHTML(team1Name, team2Name, t1Total, t2Total, t1Rows, t2Rows, index) {
        const id = `game-${index}`;
        return `
            <div class="game-container">
                <div class="game-header" onclick="
                    const body = document.getElementById('${id}');
                    body.style.display = body.style.display === 'block' ? 'none' : 'block';
                ">
                    ${team1Name} (${t1Total}) vs ${team2Name} (${t2Total})
                </div>
                <div class="game-body" id="${id}">
                    <div class="team-roster">
                        <div class="roster-title">${team1Name}</div>
                        ${t1Rows.join('')}
                    </div>
                    <div class="team-roster">
                        <div class="roster-title">${team2Name}</div>
                        ${t2Rows.join('')}
                    </div>
                </div>
            </div>`;
    }

    // --- MAIN LOGIC ---

    async function loadGames() {
        const loading = document.getElementById('loading-indicator');
        const container = document.getElementById('games-container');
        
        try {
            // 1. Find the active season
            loading.textContent = "Finding active season...";
            const seasonsQuery = query(collection(db, getCollectionName("seasons")), where("status", "==", "active"), limit(1));
            const activeSeasonsSnap = await getDocs(seasonsQuery);
            if (activeSeasonsSnap.empty) throw new Error("No active season found.");
            const activeSeasonId = activeSeasonsSnap.docs[0].id;
            
            // 2. Fetch today's games from all relevant subcollections
            loading.textContent = "Fetching today's schedule...";
            const todayStr = getTodayString();
            const gameCollectionNames = ['games', 'exhibition_games', 'post_games'];
            const gamePromises = gameCollectionNames.map(name =>
                getDocs(query(collection(db, `${getCollectionName('seasons')}/${activeSeasonId}/${getCollectionName(name)}`), where("date", "==", todayStr)))
            );
            
            const gameSnapshots = await Promise.all(gamePromises);
            const todaysGames = gameSnapshots.flatMap(snap => snap.docs.map(d => ({ id: d.id, ...d.data() })));

            if (todaysGames.length === 0) {
                loading.textContent = `No games scheduled for today (${todayStr}).`;
                return;
            }

            // 3. Fetch live game data (lineups) and process each game
            let loadedPlayers = 0;
            const totalPlayers = todaysGames.length * 12; // Estimate for progress bar

            const updateProgress = () => {
                loading.textContent = `Loaded ${++loadedPlayers} of ${totalPlayers} players...`;
            };
            
            for (let i = 0; i < todaysGames.length; i++) {
                const game = todaysGames[i];
                
                // Construct the canonical game ID for the live_games collection
                const [year, month, day] = game.date.split('/').reverse();
                const formattedDate = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                const sortedTeams = [game.team1_id, game.team2_id].sort();
                const liveGameId = `${formattedDate}-${sortedTeams[0]}-${sortedTeams[1]}`;
                
                const liveGameRef = doc(db, getCollectionName('live_games'), liveGameId);
                const liveGameSnap = await getDoc(liveGameRef);
                
                if (!liveGameSnap.exists()) continue; // Skip if no live data
                
                const liveGameData = liveGameSnap.data();
                
                // Fetch team names
                const teamNamePromises = [game.team1_id, game.team2_id].map(async (teamId) => {
                    if (teamNameCache.has(teamId)) return teamNameCache.get(teamId);
                    const teamRecordRef = doc(db, `${getCollectionName('v2_teams')}/${teamId}/${getCollectionName('seasonal_records')}/${activeSeasonId}`);
                    const teamSnap = await getDoc(teamRecordRef);
                    const name = teamSnap.exists() ? teamSnap.data().team_name : teamId;
                    teamNameCache.set(teamId, name);
                    return name;
                });

                const [team1Name, team2Name] = await Promise.all(teamNamePromises);

                // Process player scores for each team
                const [t1Data, t2Data] = await Promise.all([
                    processTeam(liveGameData.team1_lineup, updateProgress),
                    processTeam(liveGameData.team2_lineup, updateProgress)
                ]);

                // Render the game card
                container.innerHTML += createGameHTML(team1Name, team2Name, t1Data.total, t2Data.total, t1Data.rows, t2Data.rows, i);
            }

            loading.textContent = todaysGames.length > 0 ? 'Done.' : `No live games found for today.`;

        } catch (e) {
            loading.textContent = 'Failed to load game data.';
            console.error(e);
        }
    }

    loadGames();
  </script>
</body>
</html>